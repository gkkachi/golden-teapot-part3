{"version":3,"sources":["MyObject.ts","hexagon.ts","index.ts"],"names":[],"mappings":"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","file":"src.769e6198.map","sourceRoot":"../src","sourcesContent":["export interface MyObject {\n  vertices: number[][];\n  indices: number[][];\n}\n\nexport interface Buffers {\n  vbo: WebGLRenderbuffer;\n  ibo: WebGLRenderbuffer;\n  count: number;\n}\n\nexport function getBuffers(\n  gl: WebGLRenderingContext,\n  obj: MyObject\n): Buffers | null {\n  const _vbo = gl.createBuffer();\n  const _ibo = gl.createBuffer();\n  if (!_vbo || !_ibo) {\n    return null;\n  }\n\n  const flatten_vertices = flatten(obj.vertices);\n  const flatten_indices = flatten(obj.indices);\n\n  const buff: Buffers = {\n    vbo: _vbo as WebGLBuffer,\n    ibo: _ibo as WebGLBuffer,\n    count: flatten_indices.length\n  };\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, buff.vbo);\n  gl.bufferData(\n    gl.ARRAY_BUFFER,\n    new Float32Array(flatten_vertices),\n    gl.STATIC_DRAW\n  );\n  gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buff.ibo);\n  gl.bufferData(\n    gl.ELEMENT_ARRAY_BUFFER,\n    new Int16Array(flatten_indices),\n    gl.STATIC_DRAW\n  );\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\n  return buff;\n}\n\nfunction flatten(arr: any[][]): any[] {\n  return arr.reduce((acc, x) => acc.concat(x));\n}\n","import { MyObject } from \"./MyObject\";\n\nexport function getHexagon(length: number): MyObject {\n  return {\n    vertices: getVertices(length),\n    indices: getIndicese(length)\n  };\n}\n\nfunction getVertices(length: number): number[][] {\n  const th = 1.0 / length;\n  const tw2 = th / Math.sqrt(3);\n  const tw = tw2 * 2;\n\n  const arr = [];\n  for (let i = -length; i <= length; i++) {\n    const absi = Math.abs(i);\n\n    const y = th * i;\n    let x = tw2 * absi - 2.0 / Math.sqrt(3);\n    const n = length * 2 + 1 - absi;\n\n    for (let j = 0; j < n; j++) {\n      arr.push([x, y]);\n      x += tw;\n    }\n  }\n\n  return arr;\n}\n\nfunction triangles(top: number, bottom: number, n: number): number[][] {\n  let t = top;\n  let b = bottom;\n  const arr = [];\n\n  for (var i = 0; i < n; i++) {\n    arr.push([t, b, b + 1]);\n    t++;\n    b++;\n  }\n\n  return arr;\n}\n\nfunction getIndicese(length: number): number[][] {\n  let index = 0;\n  let num_triangles = length;\n  let arr: number[][] = [];\n\n  for (let i = 0; i < length; i++) {\n    const next_index = index + length + i + 1;\n    arr = arr.concat(triangles(next_index + 1, index, num_triangles++));\n    arr = arr.concat(triangles(index, next_index, num_triangles));\n    index = next_index;\n  }\n\n  for (let i = 0; i < length; i++) {\n    const next_index = index + 2 * length - i + 1;\n    arr = arr.concat(triangles(next_index, index, num_triangles--));\n    arr = arr.concat(triangles(index + 1, next_index, num_triangles));\n    index = next_index;\n  }\n\n  return arr;\n}\n","import { getBuffers, Buffers } from \"./MyObject\";\nimport { getHexagon } from \"./hexagon\";\n\nimport imageURL from \"./assets/images/theta360me.jpg\";\n\nvar gl: WebGLRenderingContext;\n\nwindow.onload = () => {\n  const c = document.getElementById(\"webgl\") as HTMLCanvasElement;\n\n  const width = c.width;\n  const height = c.height;\n\n  const _gl = c.getContext(\"webgl\");\n  if (!_gl) {\n    alert(\"ERROR: WebGL API is not available\");\n    return;\n  }\n\n  gl = _gl as WebGLRenderingContext;\n  if (!gl.getExtension(\"OES_standard_derivatives\")) {\n    alert(\"ERROR: Extension 'OES_standard_derivatives' was not found\");\n  }\n  glInit(width, height);\n\n  const vs = `\n    #define M_PI_INV 0.3183098861837907\n    #define M_PI_INV_HALF 0.15915494309189535\n\n    attribute vec2 xy;\n    varying float u1, u2, v, r;\n\n    void main(void) {\n      float z2 = 1.0 - dot(xy, xy);\n      float mask = step(0.0, z2);\n      float z = sqrt(z2 * mask);\n      vec3 normal = vec3(xy, z);\n      vec3 view = vec3(0.0, 0.0, 1.0);\n      vec3 light = normal * (2.0 * z) - view;\n      v = acos(light.y) * M_PI_INV;\n      u1 = atan(light.x, light.z) * M_PI_INV_HALF;\n      if(u1 > 0.0) {\n        u2 = u1;\n      } else {\n        u2 = u1 + 1.0;\n      }\n      gl_Position = vec4(xy, 0.0, 1.0);\n      r = mask;\n    }`;\n  const fs = `#extension GL_OES_standard_derivatives : enable\n    precision mediump float;\n    uniform sampler2D texture;\n    varying float u1, u2, v, r;\n\n    void main(void) {\n      float u;\n      if(fwidth(u1) <= fwidth(u2)) {\n        u = u1;\n      } else {\n        u = u2;\n      }\n      vec2 uv = vec2(u, v);\n      vec4 smpColor = texture2D(texture, uv);\n      vec3 vColor = smpColor.xyz * r;\n      gl_FragColor = vec4(vColor, 1.0);\n  }`;\n  const _program = create_program(vs, fs);\n  if (!_program) {\n    console.log(\"ERROR: failed to create a program.\");\n    return;\n  }\n\n  const program = _program as WebGLProgram;\n  const location_xy = gl.getAttribLocation(program, \"xy\");\n  gl.enableVertexAttribArray(location_xy);\n\n  const hexagon = getHexagon(16);\n  const _buff = getBuffers(gl, hexagon);\n  if (!_buff) {\n    console.log(\"ERROR: failed to create a buffer.\");\n    return;\n  }\n  const buff = _buff as Buffers;\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, buff.vbo);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buff.ibo);\n  gl.vertexAttribPointer(location_xy, 2, gl.FLOAT, false, 0, 0);\n\n  const location_t = gl.getUniformLocation(program, \"texture\");\n  const updateTexture = init_texture(location_t as WebGLUniformLocation);\n  updateTexture(imageURL);\n\n  setInterval(() => {\n    gl.drawElements(gl.TRIANGLES, buff.count, gl.UNSIGNED_SHORT, 0);\n    gl.flush();\n  }, 1000);\n\n  console.log(\"DONE.\");\n};\n\nfunction glInit(width: number, height: number) {\n  gl.viewport(0, 0, width, height);\n  gl.clearColor(0.0, 0.0, 0.0, 1.0);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n}\n\nfunction create_program(vs: string, fs: string): WebGLProgram | null {\n  const _program = gl.createProgram();\n  if (!_program) {\n    return null;\n  }\n\n  const program = _program as WebGLProgram;\n  gl.attachShader(program, create_shader(vs, gl.VERTEX_SHADER) as WebGLShader);\n  gl.attachShader(program, create_shader(\n    fs,\n    gl.FRAGMENT_SHADER\n  ) as WebGLShader);\n  gl.linkProgram(program);\n\n  if (gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    gl.useProgram(program);\n    return program;\n  } else {\n    alert(gl.getProgramInfoLog(program));\n    return null;\n  }\n}\n\nfunction create_shader(code: string, shader_type: number): WebGLShader | null {\n  const _shader = gl.createShader(shader_type);\n  if (!_shader) {\n    return null;\n  }\n\n  const shader = _shader as WebGLShader;\n  gl.shaderSource(shader, code);\n  gl.compileShader(shader);\n\n  if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    return shader;\n  } else {\n    alert(gl.getShaderInfoLog(shader));\n    return null;\n  }\n}\n\nfunction init_texture(location: WebGLUniformLocation) {\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  // Because images have to be download over the internet\n  // they might take a moment until they are ready.\n  // Until then put a single pixel in the texture so we can\n  // use it immediately. When the image has finished downloading\n  // we'll update the texture with the contents of the image.\n  const level = 0;\n  const internalFormat = gl.RGB;\n  const width = 1;\n  const height = 1;\n  const border = 0;\n  const srcFormat = internalFormat;\n  const srcType = gl.UNSIGNED_BYTE;\n  const pixel = new Uint8Array([0, 0, 255]); // opaque blue\n  gl.texImage2D(\n    gl.TEXTURE_2D,\n    level,\n    internalFormat,\n    width,\n    height,\n    border,\n    srcFormat,\n    srcType,\n    pixel\n  );\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n  gl.uniform1i(location, 0);\n\n  return (imgSrc: string) => {\n    const img = new Image();\n\n    img.onload = function() {\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        level,\n        internalFormat,\n        srcFormat,\n        srcType,\n        img\n      );\n    };\n    img.src = imgSrc;\n  };\n}\n"]}