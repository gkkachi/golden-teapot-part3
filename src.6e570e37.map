{"version":3,"sources":["MyObject.ts","hexagon.ts","index.ts"],"names":[],"mappings":"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","file":"src.6e570e37.map","sourceRoot":"../src","sourcesContent":["export class MyObject {\n  vbo: WebGLRenderbuffer | null;\n  ibo: WebGLRenderbuffer | null;\n  count: number;\n  gl: WebGLRenderingContext;\n  constructor(\n    gl: WebGLRenderingContext,\n    vertices: number[][],\n    indices: number[][]\n  ) {\n    const flatten_vertices = flatten(vertices);\n    const flatten_indices = flatten(indices);\n\n    const vbo = gl.createBuffer();\n    const ibo = gl.createBuffer();\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array(flatten_vertices),\n      gl.STATIC_DRAW\n    );\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);\n    gl.bufferData(\n      gl.ELEMENT_ARRAY_BUFFER,\n      new Int16Array(flatten_indices),\n      gl.STATIC_DRAW\n    );\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\n    this.vbo = vbo;\n    this.ibo = ibo;\n    this.count = flatten_indices.length;\n    this.gl = gl;\n  }\n\n  bind() {\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbo);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.ibo);\n  }\n\n  draw() {\n    this.bind()\n    this.gl.drawElements(this.gl.TRIANGLES, this.count, this.gl.UNSIGNED_SHORT, 0);\n  }\n}\n\nfunction flatten(arr: any[][]): any[] {\n  return arr.reduce((acc, x) => acc.concat(x));\n}\n","import { MyObject } from \"./MyObject\";\n\nexport function getHexagon(\n  gl: WebGLRenderingContext,\n  length: number\n): MyObject {\n  return new MyObject(gl, getVertices(length), getIndicese(length))\n}\n\nfunction getVertices(length: number): number[][] {\n  const th = 1.0 / length;\n  const tw2 = th / Math.sqrt(3);\n  const tw = tw2 * 2;\n\n  const arr = [];\n  for (let i = -length; i <= length; i++) {\n    const absi = Math.abs(i);\n\n    const y = th * i;\n    let x = tw2 * absi - 2.0 / Math.sqrt(3);\n    const n = length * 2 + 1 - absi;\n\n    for (let j = 0; j < n; j++) {\n      arr.push([x, y]);\n      x += tw;\n    }\n  }\n\n  return arr;\n}\n\nfunction triangles(top: number, bottom: number, n: number): number[][] {\n  let t = top;\n  let b = bottom;\n  const arr = [];\n\n  for (var i = 0; i < n; i++) {\n    arr.push([t, b, b + 1]);\n    t++;\n    b++;\n  }\n\n  return arr;\n}\n\nfunction getIndicese(length: number): number[][] {\n  let index = 0;\n  let num_triangles = length;\n  let arr: number[][] = [];\n\n  for (let i = 0; i < length; i++) {\n    const next_index = index + length + i + 1;\n    arr = arr.concat(triangles(next_index + 1, index, num_triangles++));\n    arr = arr.concat(triangles(index, next_index, num_triangles));\n    index = next_index;\n  }\n\n  for (let i = 0; i < length; i++) {\n    const next_index = index + 2 * length - i + 1;\n    arr = arr.concat(triangles(next_index, index, num_triangles--));\n    arr = arr.concat(triangles(index + 1, next_index, num_triangles));\n    index = next_index;\n  }\n\n  return arr;\n}\n","import { getHexagon } from \"./hexagon\";\n\nimport imageURL from \"./assets/images/theta360me.jpg\";\n\nvar gl: WebGLRenderingContext;\n\nwindow.onload = () => {\n  const c = document.getElementById(\"webgl\") as HTMLCanvasElement;\n\n  const width = c.width;\n  const height = c.height;\n\n  const _gl = c.getContext(\"webgl\");\n  if (!_gl) {\n    alert(\"ERROR: WebGL API is not available\");\n    return;\n  }\n\n  gl = _gl as WebGLRenderingContext;\n  if (!gl.getExtension(\"OES_standard_derivatives\")) {\n    alert(\"ERROR: Extension 'OES_standard_derivatives' was not found\");\n  }\n  glInit(width, height);\n\n  const vs = `\n    #define M_PI_INV 0.3183098861837907\n    #define M_PI_INV_HALF 0.15915494309189535\n\n    attribute vec2 xy;\n    varying float u1, u2, v, r;\n\n    void main(void) {\n      float z2 = 1.0 - dot(xy, xy);\n      float mask = step(0.0, z2);\n      float z = sqrt(z2 * mask);\n      vec3 normal = vec3(xy, z);\n      vec3 view = vec3(0.0, 0.0, 1.0);\n      vec3 light = normal * (2.0 * z) - view;\n      v = acos(light.y) * M_PI_INV;\n      u1 = atan(light.x, light.z) * M_PI_INV_HALF;\n      if(u1 > 0.0) {\n        u2 = u1;\n      } else {\n        u2 = u1 + 1.0;\n      }\n      gl_Position = vec4(xy, 0.0, 1.0);\n      r = mask;\n    }`;\n  const fs = `#extension GL_OES_standard_derivatives : enable\n    precision mediump float;\n    uniform sampler2D texture;\n    varying float u1, u2, v, r;\n\n    void main(void) {\n      float u;\n      if(fwidth(u1) <= fwidth(u2)) {\n        u = u1;\n      } else {\n        u = u2;\n      }\n      vec2 uv = vec2(u, v);\n      vec4 smpColor = texture2D(texture, uv);\n      vec3 vColor = smpColor.xyz * r;\n      gl_FragColor = vec4(vColor, 1.0);\n  }`;\n  const _program = create_program(vs, fs);\n  if (!_program) {\n    console.log(\"ERROR: failed to create a program.\");\n    return;\n  }\n\n  const program = _program as WebGLProgram;\n  const location_xy = gl.getAttribLocation(program, \"xy\");\n  gl.enableVertexAttribArray(location_xy);\n\n  const hexagon = getHexagon(gl, 16);\n  hexagon.bind();\n  gl.vertexAttribPointer(location_xy, 2, gl.FLOAT, false, 0, 0);\n\n  const location_t = gl.getUniformLocation(program, \"texture\");\n  const updateTexture = init_texture(location_t as WebGLUniformLocation);\n  updateTexture(imageURL);\n\n  setInterval(() => {\n    hexagon.draw();\n    gl.flush();\n  }, 1000);\n\n  console.log(\"DONE.\");\n};\n\nfunction glInit(width: number, height: number) {\n  gl.viewport(0, 0, width, height);\n  gl.clearColor(0.0, 0.0, 0.0, 1.0);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n}\n\nfunction create_program(vs: string, fs: string): WebGLProgram | null {\n  const _program = gl.createProgram();\n  if (!_program) {\n    return null;\n  }\n\n  const program = _program as WebGLProgram;\n  gl.attachShader(program, create_shader(vs, gl.VERTEX_SHADER) as WebGLShader);\n  gl.attachShader(program, create_shader(\n    fs,\n    gl.FRAGMENT_SHADER\n  ) as WebGLShader);\n  gl.linkProgram(program);\n\n  if (gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    gl.useProgram(program);\n    return program;\n  } else {\n    alert(gl.getProgramInfoLog(program));\n    return null;\n  }\n}\n\nfunction create_shader(code: string, shader_type: number): WebGLShader | null {\n  const _shader = gl.createShader(shader_type);\n  if (!_shader) {\n    return null;\n  }\n\n  const shader = _shader as WebGLShader;\n  gl.shaderSource(shader, code);\n  gl.compileShader(shader);\n\n  if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    return shader;\n  } else {\n    alert(gl.getShaderInfoLog(shader));\n    return null;\n  }\n}\n\nfunction init_texture(location: WebGLUniformLocation) {\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  // Because images have to be download over the internet\n  // they might take a moment until they are ready.\n  // Until then put a single pixel in the texture so we can\n  // use it immediately. When the image has finished downloading\n  // we'll update the texture with the contents of the image.\n  const level = 0;\n  const internalFormat = gl.RGB;\n  const width = 1;\n  const height = 1;\n  const border = 0;\n  const srcFormat = internalFormat;\n  const srcType = gl.UNSIGNED_BYTE;\n  const pixel = new Uint8Array([0, 0, 255]); // opaque blue\n  gl.texImage2D(\n    gl.TEXTURE_2D,\n    level,\n    internalFormat,\n    width,\n    height,\n    border,\n    srcFormat,\n    srcType,\n    pixel\n  );\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n  gl.uniform1i(location, 0);\n\n  return (imgSrc: string) => {\n    const img = new Image();\n\n    img.onload = function() {\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        level,\n        internalFormat,\n        srcFormat,\n        srcType,\n        img\n      );\n    };\n    img.src = imgSrc;\n  };\n}\n"]}